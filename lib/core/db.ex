defmodule Core.DB do
  use Ecto.Repo,
    otp_app: :elixir_ai_core,
    adapter: Ecto.Adapters.Postgres

  import Ecto.Query
  alias BrainCell

  # ── Lookups ───────────────────────────────────────────────────────────────────

  @doc "Checks if any brain cell exists for the given word."
  def has_word?(word) when is_binary(word) do
    query =
      from b in BrainCell,
        where: b.word == ^word,
        select: 1

    exists?(query)
  end

  @doc "Checks if a brain cell exists for the given id."
  def cell_exists?(id) do
    query =
      from b in BrainCell,
        where: b.id == ^id,
        select: 1

    exists?(query)
  end

  def get_cells_for_phrase(phrase), do: get_braincells_by_word(phrase)

  @doc """
  Gets all brain cells for a given word (downcased).
  Returns an empty list if none found.
  """
  def get_braincells_by_word(word) when is_binary(word) do
    from(b in BrainCell, where: b.word == ^String.downcase(word))
    |> all()
  end

  # ── Inserts ───────────────────────────────────────────────────────────────────

  def insert_cell!(%BrainCell{} = cell), do: __MODULE__.insert!(cell)

  def insert_all(cells) when is_list(cells) do
    Enum.each(cells, fn cell ->
      unless cell_exists?(cell.id) do
        insert_cell!(cell)
      end
    end)
  end

  # ── Backup / Restore ──────────────────────────────────────────────────────────

  @doc """
  Backup all BrainCell rows to `priv/repo/backup.exs` as a list of `%BrainCell{}` structs.
  Uses an atomic write (tmp file + rename). Returns {:ok, path, count}.
  """
  def backup_braincells(path \\ "priv/repo/backup.exs") do
    dir  = Path.dirname(path)
    tmp  = path <> ".tmp"
    File.mkdir_p!(dir)

    cells = all(from b in BrainCell)
    ts = DateTime.utc_now() |> DateTime.to_iso8601()

    body = [
      "# Auto-generated by Core.DB.backup_braincells/1 at ", ts, "\n",
      "alias BrainCell\n",
      "[\n",
      cells |> Enum.map(&to_struct_literal/1) |> Enum.intersperse(",\n"),
      "\n]\n"
    ]

    # Atomic write
    :ok = File.write(tmp, IO.iodata_to_binary(body), [:binary])
    :ok = File.rename(tmp, path)
    {:ok, path, length(cells)}
  end

  @doc """
  Streamed backup (memory-friendly for huge tables).
  Writes the same list-of-structs format using an atomic write.
  """
  def backup_braincells_stream(path \\ "priv/repo/backup.exs") do
    dir  = Path.dirname(path)
    tmp  = path <> ".tmp"
    File.mkdir_p!(dir)

    {:ok, io} = File.open(tmp, [:write, :binary])  # binary avoids :no_translation

    try do
      ts = DateTime.utc_now() |> DateTime.to_iso8601()
      IO.binwrite(io, "# Auto-generated by Core.DB.backup_braincells_stream/1 at #{ts}\n")
      IO.binwrite(io, "alias BrainCell\n[\n")

      count =
        case __MODULE__.transaction(fn ->
               stream(from b in BrainCell)
               |> Enum.reduce(0, fn cell, acc ->
                 sep = if acc == 0, do: "", else: ",\n"
                 IO.binwrite(io, sep)
                 IO.binwrite(io, to_struct_literal(cell))
                 acc + 1
               end)
             end) do
          {:ok, c} -> c
          {:error, reason} -> raise "backup transaction failed: #{inspect(reason)}"
        end

      IO.binwrite(io, "\n]\n")
      :ok = File.close(io)
      :ok = File.rename(tmp, path)
      {:ok, path, count}
    rescue
      e ->
        # Ensure tmp is cleaned up on error
        File.close(io)
        File.rm_rf(tmp)
        reraise e, __STACKTRACE__
    end
  end

  @doc """
  Restore braincells from a backup.exs file (list of %BrainCell{} structs).
  Idempotent: skips rows whose IDs already exist.
  Returns {:ok, count}.
  """
  def restore_braincells(path \\ "priv/repo/backup.exs") do
    {cells, _binding} = Code.eval_file(path)
    list = List.wrap(cells)
    insert_all(list)
    {:ok, length(list)}
  end

  # ── Helpers ───────────────────────────────────────────────────────────────────

  # Convert an Ecto schema into a literal `%BrainCell{...}` string for .exs
  defp to_struct_literal(%BrainCell{} = cell) do
    cell
    |> Map.from_struct()
    |> Map.drop([:__meta__]) # drop Ecto metadata
    |> Enum.sort_by(fn {k, _} -> k end)
    |> Enum.map(fn {k, v} ->
      "  #{k}: #{inspect(v, limit: :infinity, printable_limit: :infinity)}"
    end)
    |> Enum.join(",\n")
    |> then(&"%BrainCell{\n" <> &1 <> "\n}")
  end
end

